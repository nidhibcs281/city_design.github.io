<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Course Reflections</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      line-height: 1.6;
      background-color: #f4f4f9;
      color: #333;
      margin: 0;
      padding: 20px;
    }
    h1 {
      text-align: center;
      color: #444;
    }
    h2 {
      color: #333;
    }
    p {
      font-size: 16px;
    }
    ul {
      list-style-type: disc;
      padding-left: 20px;
    }
    li {
      margin-bottom: 10px;
    }
    .section {
      margin-top: 20px;
    }
  </style>
</head>
<body>

  <h1>Course Reflections</h1>
  
  <div class="section">
    <h2>Q1: What are the kinds of problems we see in nature? (iteration, recursion, backtracking)</h2>
    <p>Nature presents us with a variety of problems that often mirror how we solve challenges in the world of algorithms. Here’s a look at common approaches like iteration, recursion, and backtracking:</p>
    <ul>
      <li><strong>Iteration</strong>: Counting coins, cell division.</li>
      <li><strong>Recursion</strong>: Growth of a tree, branch splitting.</li>
      <li><strong>Backtracking</strong>: Sudoku puzzles, animal foraging.</li>
    </ul>
  </div>

  <div class="section">
    <h2>Q2: Time and Space Efficiency</h2>
    <p><strong>Space Efficiency</strong>: Refers to the additional memory needed during execution.</p>
    <p><strong>Time Efficiency</strong>: Measures how long an algorithm takes to complete.</p>
    <p><strong>Orders of Growth</strong>: The growth rates of algorithms are classified as:
    <ul>
      <li>O(1) &lt; O(log(n)) &lt; O(n) &lt; O(n log(n)) &lt; O(n²) &lt; O(n³) &lt; O(2ⁿ) &lt; O(n!)</li>
    </ul>
    </p>
  </div>

  <div class="section">
    <h2>Q3: Takeaways from Design Principles</h2>
    <ul>
      <li><strong>Decomposition</strong>: Breaking problems into smaller subproblems.</li>
      <li><strong>Abstraction</strong>: Simplifying problems by ignoring irrelevant details.</li>
      <li><strong>Brave and Cautious Travel</strong>: Exploring paths optimistically or conservatively.</li>
      <li><strong>Level Order Traversal</strong>: Visiting nodes level by level.</li>
      <li><strong>Hierarchical Data</strong>: Organizing data in layers.</li>
      <li><strong>Edge Relaxation</strong>: Updating edge weights to find shortest paths.</li>
      <li><strong>Balancing and Rotations</strong>: Ensuring structures remain balanced.</li>
      <li><strong>Parental Dominance</strong>: Parent nodes dominate their child nodes.</li>
      <li><strong>Partitioning</strong>: Dividing data into segments.</li>
      <li><strong>Shortest Path Trees</strong>: Constructing trees for shortest paths.</li>
    </ul>
  </div>

  <div class="section">
    <h2>Q4: Hierarchical Data and Tree Structures</h2>
    <p>Different tree data structures help solve problems related to hierarchical data. For example, Binary Search Trees (BSTs) and AVL trees offer fast searching, while heaps help with efficient priority queue management.</p>
  </div>

  <div class="section">
    <h2>Q5: Differences Between Trees and Graphs</h2>
    <p><strong>Tree</strong>: Hierarchical structure with no cycles.</p>
    <p><strong>Graph</strong>: Can have cycles and multiple connections.</p>
  </div>

  <div class="section">
    <h2>Q6: Sorting and Searching Algorithms</h2>
    <p><strong>Bubble Sort</strong>: Repeatedly compares adjacent elements and swaps them.</p>
    <p><strong>Selection Sort</strong>: Finds the minimum element and swaps it.</p>
    <p><strong>Merge Sort</strong>: Divides and conquers to sort arrays.</p>
    <p><strong>Quick Sort</strong>: Selects a pivot to partition and sort arrays.</p>
    <p><strong>Linear Search</strong>: Checks each element until the target is found.</p>
    <p><strong>Binary Search</strong>: Divides the list in half to find the target quickly.</p>
  </div>

  <div class="section">
    <h2>Q7: Importance of Graph Algorithms</h2>
    <p>Graph algorithms like Prim’s, Kruskal’s for spanning trees, and Dijkstra’s for shortest paths are used in network routing, transportation systems, and GPS navigation.</p>
  </div>

</body>
</html>
